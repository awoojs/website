
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>weh</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/tachyons.css">
  </head>
  <body>
    <article class="pv2 ph5 sans-serif">
      <h1 class="f3 f2-m f1-l">weh docs</h1>
      <h2>weh API</h2>
<h3>weh(function (site))</h3>
<p>Builds a site. This function takes another function that describes how the site
is built. Basically, it looks like this:</p>
<pre><code class="language-js">weh(async site =&gt; {
  // your site definition here
  return site
})
</code></pre>
<p>This function takes a <code>site</code> parameter. This parameter is responsible for
configuring your entire site, and all of its methods are documented below.</p>
<p>This function needs to return <code>site</code>, wrapped in a promise. Thankfully,
making it return a promise is as easy as using the <code>async</code> keyword
(see the above example).</p>
<h3>weh.integration(function (site), files)</h3>
<p>Basically the same as <code>weh()</code>, but sets <code>dry_run</code> to true and accepts an array
of files to set as <code>config.files</code>, in order to override the read process.
Used in integration tests for plugins.</p>
<h3>site.config(conf)</h3>
<p>Configures your site with either a specified config object or the default config.
You don't <em>need</em> to call this function in your build process - if you omit it,
<code>weh</code> will use the <a href="#default-configuration">default config</a> instead, though you'd probably want to
adjust your source and destination paths.</p>
<h3>site.use(plugin, [options])</h3>
<p>Registers a plugin to be used in the build process. See <a href="#plugin-structure">plugin structure</a> for
more information on how to write plugins.</p>
<p>The <code>options</code> argument is optional and can be used to pass plugin-specific
options. It should be an object, although that is up to each plugin to
decide.</p>
<h3>Default Configuration</h3>
<p>This is an exhaustive list of all <code>weh</code> config options:</p>
<ul>
<li><strong>source</strong>: The source directory where files are being read from. The default
is the directory you're running <code>weh</code> from.</li>
<li><strong>destination</strong>: The directory <code>weh</code> will place built files into. The default
is the directory you're in + <code>_site</code> (just like Jekyll!)</li>
<li><strong>no_read</strong>: Whether to skip reading. This should be coupled with using <code>config.files</code>.</li>
<li><strong>no_write</strong>: Whether to skip writing completely. This is useful if you want to run
automated tests without writing to disk. Default is <code>false</code>.</li>
<li><strong>files</strong>: An array that will override <code>site.files</code> when <code>dry_run</code> is also set to true.</li>
<li><strong>exclude</strong>: Files and directories to exclude when reading. The default is:</li>
</ul>
<pre><code>node_modules/
package.json
bower_components/
coverage/
</code></pre>
<p>If you have any suggestions on what should be excluded by default, please open
an issue!</p>
<h2>Plugin Structure</h2>
<p>The plugin itself is a function. It can take an optional <code>options</code>
parameter, which the user can pass through in the <code>site.use</code> call:</p>
<pre><code class="language-js">const plugin = (opts = {}) =&gt; {
  // do something cool
}
</code></pre>
<p>It's best to set this to <code>{}</code> as a default to prevent unwanted errors, even
if your plugin isn't taking any options.</p>
<p>The function receives one parameter, namely the <code>files</code> parameter. This is a big
array that contains all of the data collectible from the source fileset. The files
are stores as <a href="vfile"><code>vfile</code></a>s, which is a virtual file format used to easily
serialize and deserialize files to and from the disk, and also through middleware.</p>
<p>Thankfully, <code>vfiles</code>s are just normal objects (with a bit of sugar on top), which
means you can easily modify every aspect of the file. A couple of important attributes
that every <code>vfile</code> has:</p>
<ul>
<li><code>contents</code></li>
<li><code>path</code> (this is a path relative to the source directory, e.g. <code>test.md</code>)</li>
<li><code>extname</code> (the name of the file extension)</li>
<li><code>dirname</code> (the name of the parent directory)</li>
<li><code>data</code> (this is where you store custom data related to the file)</li>
</ul>
<p>If <code>weh</code> stumbles upon a binary file, it is kept in a buffer structure, because
converting it to a string would effectively break the file. You can filter
binary files from your fileset like this:</p>
<pre><code class="language-js">const onlyTextFiles = files.filter(file =&gt; typeof file.contents === 'string')
</code></pre>
<p>And that's it! You can modify all of the parts you want, just be sure to return
the (modified) <code>files</code> object at the end.</p>
<p>So, to recap, your plugin might look a little like this:</p>
<pre><code class="language-js">const plugin = opts =&gt; {
  return files =&gt; files.map(file =&gt; {
    file.contents = opts || 'test'
    return file
  })
}

// ...omit weh initialization
site.use(plugin, `haha i\'ve replaced your file!`)
// ...omit other weh stuff
</code></pre>
<p>Of course, you can put this into a npm module and publish it for the world to
see! I advise that you add the <code>weh</code> tag to your package so that it remains
discoverable.</p>

    </article>
  </body>
</html>
